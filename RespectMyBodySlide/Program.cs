using System;
using System.Collections.Generic;
using System.Linq;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using System.Threading.Tasks;
using Mutagen.Bethesda.Plugins;
using System.IO;

namespace RespectMyBodySlide
{
    public class Program
    {
        private static Lazy<Settings> settingsLoader = new(() => new Settings());

        public static Settings Settings => settingsLoader.Value;

        private static readonly FormKey ActorTypeNpcKeywordFormKey = FormKey.Factory("013794:Skyrim.esm");

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings("Settings", "settings.json", out settingsLoader)
                .SetTypicalOpen(GameRelease.SkyrimSE, "RespectMyBodySlide.esp")
                .Run(args);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            var implicits = Implicits.Get(state.PatchMod.GameRelease).Listings.ToHashSet();
            var skipModNames = implicits
                .Select(x => x.Name)
                .Concat(Settings.IgnoredModNames.Select(f => Path.GetFileNameWithoutExtension(f)))
                .Append(state.PatchMod.ModKey.Name)
                .ToHashSet(StringComparer.OrdinalIgnoreCase);
            var listings = state.LoadOrder.PriorityOrder.Where(x => x.Enabled && !skipModNames.Contains(x.ModKey.Name));
            var seenNpcs = new HashSet<FormKey>();
            foreach (var listing in listings)
            {
                Console.WriteLine($"Checking mod: {listing.ModKey.Name}");
                foreach (var npc in listing.Mod!.Npcs.Where(x => !seenNpcs.Contains(x.FormKey)))
                {
                    PatchNpc(npc, implicits, state);
                    seenNpcs.Add(npc.FormKey);
                }
            }
        }

        private static string FormatNpc(INpcGetter npc)
        {
            return $"{npc.FormKey} ({npc.EditorID} - '{npc.Name}')";
        }

        private static void PatchNpc(
            INpcGetter npc, IReadOnlySet<ModKey> implicits, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            var race = npc.Race.Resolve(state.LinkCache);
            if (!race.Keywords?.Contains(ActorTypeNpcKeywordFormKey) ?? false)
                return;

            if (npc.WornArmor.IsNull)
                return;

            if (implicits.Contains(npc.FormKey.ModKey))
            {
                var masterNpc = npc.AsLink().ResolveAll(state.LinkCache).Last();
                if (masterNpc.WornArmor == npc.WornArmor)
                {
                    Console.WriteLine(
                        $"NPC {FormatNpc(npc)} uses the same worn armor as the vanilla master and will be skipped.");
                    return;
                }
            }


            if (!Settings.KeepWigs)
            {
                // Makes code a bit repetitive, but we can skip potentially expensive checks.
                Console.WriteLine($"Removing WNAM from NPC {FormatNpc(npc)}");
                ReplaceWornArmor(npc, null, state);
                return;
            }

            var wornArmor = npc.WornArmor.Resolve(state.LinkCache);
            var addons = wornArmor.Armature.Select(x => x.Resolve(state.LinkCache)).ToList();
            if (addons.All(x => !IsBodyPart(x)))
            {
                // Armor doesn't touch any body parts, therefore no need to patch.
                Console.WriteLine(
                    $"NPC {FormatNpc(npc)} uses worn armor {wornArmor.FormKey} ({wornArmor.EditorID}) which does not " +
                    "use any body slots. This NPC will be skipped.");
                return;
            }

            // At least one part of the armor affects the body.
            var hairAddons = addons.Where(x => IsHair(x)).ToList();
            if (hairAddons.Count == 0)
            {
                Console.WriteLine(
                    $"Removing body-modifying WNAM {wornArmor.FormKey} ({wornArmor.EditorID}) from NPC " +
                    $"{FormatNpc(npc)}");
                ReplaceWornArmor(npc, null, state);
            }
            else if (Settings.SeparateWigs && !state.PatchMod.Armors.ContainsKey(wornArmor.FormKey))
            {
                Console.WriteLine(
                    $"Patching armor {wornArmor.FormKey} ({wornArmor.EditorID}) to remove body parts and keep only " +
                    "hair/wigs.");
                var patchedArmor = state.PatchMod.Armors.GetOrAddAsOverride(wornArmor);
                var hairKeys = hairAddons.Select(x => x.FormKey).ToHashSet();
                patchedArmor.Armature.RemoveAll(x => !hairKeys.Contains(x.FormKey));
                // Don't actually need to touch the NPC, since the armor itself is patched.
            }
        }

        private static void ReplaceWornArmor(
            INpcGetter npc, FormKey? wornArmorKey, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            var patchedNpc = state.PatchMod.Npcs.GetOrAddAsOverride(npc);
            patchedNpc.WornArmor.FormKeyNullable = wornArmorKey;
        }

        private static bool IsBodyPart(IArmorAddonGetter addon)
        {
            if (addon.BodyTemplate == null)
                return false;
            return
                addon.BodyTemplate.FirstPersonFlags.HasFlag(BipedObjectFlag.Body) ||
                addon.BodyTemplate.FirstPersonFlags.HasFlag(BipedObjectFlag.Calves) ||
                addon.BodyTemplate.FirstPersonFlags.HasFlag(BipedObjectFlag.Feet) ||
                addon.BodyTemplate.FirstPersonFlags.HasFlag(BipedObjectFlag.Forearms) ||
                addon.BodyTemplate.FirstPersonFlags.HasFlag(BipedObjectFlag.Hands) ||
                addon.BodyTemplate.FirstPersonFlags.HasFlag(BipedObjectFlag.Tail);
        }

        private static bool IsHair(IArmorAddonGetter addon)
        {
            if (addon.BodyTemplate == null)
                return false;
            return
                addon.BodyTemplate.FirstPersonFlags.HasFlag(BipedObjectFlag.Hair) ||
                addon.BodyTemplate.FirstPersonFlags.HasFlag(BipedObjectFlag.LongHair);
        }
    }
}
